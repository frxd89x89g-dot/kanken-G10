<!doctype html>
<html lang="ja">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Êº¢Ê§ú10Á¥ö„Éû„Çπ„Çø„ÉºÔºàÂêàÊ†ºÂäõ√ó20ÂïèÂå∫Âàá„Çä√óÊõ∏„ÅçÈ†ÜÂØæÂøúÔºâ</title>
  <style>
    :root {
      --bg: #eef7ff;
      --card: #fff;
      --text: #0f172a;
      --muted: #64748b;
      --primary: #60a5fa;
      --accent: #fbbf24;
      --good: #22c55e;
      --bad: #ef4444;
      --shadow: 0 12px 30px rgba(0, 0, 0, .08);
      --radius: 18px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif;
      background:
        radial-gradient(circle at 15% 15%, rgba(251, 191, 36, .18) 0 120px, transparent 120px),
        radial-gradient(circle at 85% 25%, rgba(96, 165, 250, .18) 0 160px, transparent 160px),
        radial-gradient(circle at 35% 85%, rgba(239, 68, 68, .10) 0 140px, transparent 140px),
        var(--bg);
      color: var(--text);
      overflow: hidden;
      user-select: none;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    header {
      position: fixed;
      inset: 0 0 auto 0;
      padding: 12px 12px 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(255, 255, 255, .78);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(0, 0, 0, .06);
      z-index: 20;
      gap: 10px;
      flex-wrap: wrap;
    }

    .hud {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      font-weight: 1000;
    }

    .pill {
      background: #fff;
      border: 1px solid rgba(0, 0, 0, .06);
      box-shadow: var(--shadow);
      padding: 8px 10px;
      border-radius: 999px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      white-space: nowrap;
    }

    .barWrap {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .bar {
      width: 220px;
      height: 10px;
      border-radius: 999px;
      background: #e5f0ff;
      border: 1px solid rgba(0, 0, 0, .06);
      overflow: hidden;
    }

    .gauge {
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, #22c55e, #16a34a);
      transition: width .25s ease;
    }

    .btnGhost {
      background: #fff;
      border: 1px solid rgba(0, 0, 0, .08);
      color: #334155;
      box-shadow: var(--shadow);
      padding: 10px 12px;
      border-radius: 999px;
      font-weight: 1000;
      cursor: pointer;
      white-space: nowrap;
      touch-action: manipulation;
    }

    .btnGhost:active {
      transform: translateY(1px);
    }

    main {
      position: fixed;
      inset: 70px 0 0 0;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 14px;
    }

    .screen {
      width: min(580px, 94vw);
      background: var(--card);
      border: 1px solid rgba(0, 0, 0, .06);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px;
      position: relative;
      animation: pop .22s ease;
    }

    @keyframes pop {
      from {
        transform: scale(.98);
        opacity: .5;
      }

      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    .tag {
      position: absolute;
      top: 14px;
      left: 14px;
      background: #e8f3ff;
      color: #1d4ed8;
      border-radius: 999px;
      padding: 6px 10px;
      font-weight: 1000;
      font-size: 13px;
    }

    .title {
      text-align: center;
      margin: 34px 0 6px;
      font-size: 38px;
      font-weight: 1100;
      color: #2563eb;
      letter-spacing: .02em;
    }

    .subtitle {
      text-align: center;
      margin: 0 0 14px;
      font-weight: 1000;
      color: #f43f5e;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 16px;
    }

    .btn {
      border: 0;
      border-radius: 14px;
      padding: 14px 12px;
      font-weight: 1100;
      cursor: pointer;
      background: #bfe0ff;
      color: #0b3b73;
      box-shadow: inset 0 -3px 0 rgba(0, 0, 0, .08);
      font-size: 16px;
      touch-action: manipulation;
      appearance: none;
      -webkit-appearance: none;
    }

    .btn:active {
      transform: translateY(1px);
      box-shadow: inset 0 -2px 0 rgba(0, 0, 0, .08);
    }

    .btnAccent {
      background: #fde68a;
      color: #5b3a00;
    }

    .btnWide {
      width: 100%;
    }

    .qBigKanji {
      font-size: 96px;
      text-align: center;
      margin: 18px 0 6px;
      line-height: 1;
      font-weight: 1100;
    }

    .qBigKana {
      font-size: 56px;
      text-align: center;
      margin: 22px 0 6px;
      line-height: 1.2;
      font-weight: 1100;
    }

    .prompt {
      text-align: center;
      font-weight: 1100;
      color: #334155;
      margin: 8px 0 10px;
    }

    .counter {
      text-align: center;
      color: var(--muted);
      font-weight: 1000;
      font-size: 13px;
      margin: 6px 0 0;
    }

    .choices {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 12px;
    }

    /* ‚úÖ ÈáçË¶ÅÔºöiPhone„ÅßÁ¢∫ÂÆü„Å´ÂèçÂøú„Åô„Çã„Çà„ÅÜ button „Å´„Åô„Çã */
    .choice {
      width: 100%;
      background: #bfe0ff;
      border: 1px solid rgba(0, 0, 0, .06);
      border-radius: 14px;
      padding: 14px 12px;
      font-weight: 1100;
      font-size: 20px;
      text-align: center;
      cursor: pointer;
      box-shadow: inset 0 -3px 0 rgba(0, 0, 0, .08);
      touch-action: manipulation;
      appearance: none;
      -webkit-appearance: none;
    }

    .choice:active {
      transform: translateY(1px);
      box-shadow: inset 0 -2px 0 rgba(0, 0, 0, .08);
    }

    .explain {
      margin-top: 10px;
      font-weight: 1000;
      color: var(--muted);
      text-align: center;
      font-size: 13px;
      display: none;
    }

    /* ‚úÖ Overlay Feedback */
    .feedback-overlay {
      position: fixed;
      inset: 0;
      z-index: 100;
      display: none;
      justify-content: center;
      align-items: center;
      background: rgba(255, 255, 255, 0.85);
      font-size: 48px;
      font-weight: 1200;
      animation: pop .1s ease;
      text-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    }

    .feedback-correct {
      color: #22c55e;
    }

    .feedback-wrong {
      color: #ef4444;
    }

    .toast {
      /* Keep existing toast if needed, but overlay is primary */
      position: fixed;
      left: 50%;
      bottom: 14px;
      transform: translateX(-50%);
      background: rgba(15, 23, 42, .92);
      color: #fff;
      padding: 12px 14px;
      border-radius: 999px;
      font-weight: 1100;
      box-shadow: var(--shadow);
      display: none;
      max-width: 94vw;
      text-align: center;
      z-index: 50;
    }

    .svgBox {
      width: 240px;
      height: 240px;
      margin: 18px auto 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #fff;
      border-radius: 16px;
      border: 1px solid rgba(0, 0, 0, .06);
      box-shadow: inset 0 -3px 0 rgba(0, 0, 0, .05);
    }

    svg {
      width: 220px;
      height: 220px;
    }

    .strokeBase {
      stroke: #111827;
      stroke-width: 9;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
      opacity: .22;
    }

    .strokeRed {
      stroke: #ff3b30;
      stroke-width: 10;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
      opacity: 1;
      filter: drop-shadow(0 2px 0 rgba(0, 0, 0, .06));
    }

    .loading {
      padding: 46px 0 18px;
      text-align: center;
      color: var(--muted);
      font-weight: 1100;
    }

    .spinner {
      width: 34px;
      height: 34px;
      border-radius: 50%;
      border: 4px solid #dbeafe;
      border-top-color: #2563eb;
      margin: 0 auto 12px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .footerNote {
      margin-top: 14px;
      font-size: 12px;
      color: var(--muted);
      font-weight: 900;
      line-height: 1.4;
      text-align: center;
      white-space: pre-line;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      margin-top: 10px;
    }

    .chip {
      background: #f1f5f9;
      border: 1px solid rgba(0, 0, 0, .06);
      border-radius: 999px;
      padding: 6px 10px;
      font-weight: 1100;
      font-size: 13px;
      color: #334155;
    }

    .chipGood {
      background: #dcfce7;
      border-color: #86efac;
      color: #14532d;
    }

    .chipNew {
      background: #fff7ed;
      border-color: #fed7aa;
      color: #7c2d12;
    }

    .warn {
      background: #fff7ed;
      border: 1px solid rgba(0, 0, 0, .06);
      border-radius: 14px;
      padding: 10px 12px;
      font-weight: 1000;
      color: #7c2d12;
      margin-top: 12px;
      line-height: 1.4;
      white-space: pre-line;
    }

    /* ‚úÖ JS„ÅåËêΩ„Å°„ÅüÊôÇ„Å´„ÄåÁÑ°ÂèçÂøú„Äç„Å´„Å™„Çâ„Å™„ÅÑ„Åü„ÇÅ„ÅÆ„Ç™„Éº„Éê„Éº„É¨„Ç§ */
    .fatal {
      position: fixed;
      inset: 0;
      background: rgba(255, 255, 255, .92);
      display: none;
      z-index: 9999;
      padding: 16px;
      overflow: auto;
    }

    .fatal h2 {
      margin: 8px 0;
      color: #ef4444;
    }

    .fatal pre {
      background: #0f172a;
      color: #e2e8f0;
      padding: 12px;
      border-radius: 12px;
      white-space: pre-wrap;
      word-break: break-word;
      font-size: 12px;
    }
  </style>
</head>

<body>
  <header>
    <div class="hud">
      <div class="pill">Lv.<span id="level">1</span></div>
      <div class="pill">ÂÆåÊàê(„É©„É≥„ÇØ3) <span id="mastered">0</span>/80</div>
      <div class="pill">„Åì„ÅÆ„Çª„ÉÉ„Éà <span id="todayDone">0</span>/<span id="limit">20</span></div>
      <div class="barWrap">
        <div style="font-weight:1100;color:#334155;">ÂÆåÊàê„É°„Éº„Çø„Éº</div>
        <div class="bar">
          <div id="gauge" class="gauge"></div>
        </div>
      </div>
    </div>
    <div style="display:flex; gap:10px; align-items:center;">
      <button class="btnGhost" id="homeBtn" type="button">„Éõ„Éº„É†</button>
      <button class="btnGhost" id="resetBtn" type="button" title="Â≠¶Áøí„Éá„Éº„Çø„ÇíÂàùÊúüÂåñ„Åó„Åæ„Åô">„É™„Çª„ÉÉ„Éà</button>
    </div>
  </header>

  <main id="root"></main>

  <div class="feedback-overlay" id="feedback"></div>
  <div class="toast" id="toast"></div>

  <div class="fatal" id="fatal">
    <h2>„Ç®„É©„Éº„ÅßÂÅúÊ≠¢„Åó„Åæ„Åó„Åü</h2>
    <div class="warn">„Åì„ÅÆÁîªÈù¢„ÅåÂá∫„Åü„Çâ„ÄÅJavaScript„Åå„Å©„Åì„Åã„ÅßËêΩ„Å°„Å¶„ÅÑ„Åæ„Åô„ÄÇ‰∏ã„ÅÆÂÜÖÂÆπ„Çí„Åù„ÅÆ„Åæ„ÅæË≤º„Çå„Å∞ÂéüÂõ†„ÇíÂç≥ÁâπÂÆö„Åß„Åç„Åæ„Åô„ÄÇ</div>
    <pre id="fatalText"></pre>
  </div>

  <script>
    /* =========================================================
       Êº¢Ê§ú10Á¥ö„Éû„Çπ„Çø„ÉºÔºàÂêàÊ†ºÂäõ√óÂå∫Âàá„Çä√óÊõ∏„ÅçÈ†ÜÔºâ
       - 80Â≠óÔºöÁøíÂæó„É©„É≥„ÇØ 0..3Ôºà0Êú™/1Ë™≠„Åø/2ÈÅ∏ÊäûÊõ∏„Åç/3Êõ∏„ÅçÈ†ÜÔºâ
       - ÂÖ®‰ΩìLvÔºö„É©„É≥„ÇØ3„ÅÆÂ≠óÊï∞„Åß10Â≠ó„Åî„Å®„Å´‰∏äÊòáÔºàÁµÇ„Çè„Çä„Åå„ÅÇ„ÇãÔºâ
       - ÂêÑÂ≠¶Áøí„É¢„Éº„ÉâÔºö20Âïè„ÅßÂøÖ„ÅöÁµÇ‰∫ÜÔºàÊ®°Ë©¶„ÅØ10ÂïèÔºâ
       - Êõ∏„ÅçÈ†ÜÔºöKanjiVG„ÅÆ„Çπ„Éà„É≠„Éº„ÇØÈ†ÜSVG„Åã„Çâ„ÄåËµ§„ÅÑÁ∑ö„ÅØ‰ΩïÁîªÁõÆÔºü„Äç„ÇíÁîüÊàê
         ‚ÄªÂàùÂõû„Å†„Åë„Éç„ÉÉ„ÉàÂøÖË¶Å„ÄÇÂ§±Êïó„Åó„Åü„ÇâÂøÖ„ÅöÊàª„ÇãÔºàÂõ∫„Åæ„Çâ„Å™„ÅÑÔºâ
       ========================================================= */

    const root = document.getElementById("root");
    const toastEl = document.getElementById("toast");
    const feedbackEl = document.getElementById("feedback");
    const levelEl = document.getElementById("level");
    const masteredEl = document.getElementById("mastered");
    const todayDoneEl = document.getElementById("todayDone");
    const limitEl = document.getElementById("limit");
    const gaugeEl = document.getElementById("gauge");

    const fatalEl = document.getElementById("fatal");
    const fatalText = document.getElementById("fatalText");
    function showFatal(message) {
      fatalText.textContent = message || "Unknown error";
      fatalEl.style.display = "block";
    }

    function toast(msg) {
      toastEl.textContent = msg;
      toastEl.style.display = "block";
      clearTimeout(toast._t);
      toast._t = setTimeout(() => toastEl.style.display = "none", 1200);
    }

    function showFeedback(isCorrect, msg) {
      feedbackEl.className = "feedback-overlay " + (isCorrect ? "feedback-correct" : "feedback-wrong");
      feedbackEl.innerHTML = msg;
      feedbackEl.style.display = "flex";
      setTimeout(() => {
        feedbackEl.style.display = "none";
      }, 700);
    }

    function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
    function shuffle(arr) {
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    /* ‚úÖ iOS„ÅÆ :active „ÇíÂäπ„Åã„Åõ„Çã„Åä„Åæ„Åò„Å™„ÅÑÔºàÂâØ‰ΩúÁî®„Å™„ÅóÔºâ */
    document.addEventListener("touchstart", () => { }, { passive: true });

    function el(tag, attrs = {}, children = []) {
      const n = document.createElement(tag);

      for (const [k, v] of Object.entries(attrs)) {
        if (k === "class") n.className = v;
        else if (k === "style") n.setAttribute("style", v);
        else if (k.startsWith("on") && typeof v === "function") {
          const ev = k.slice(2).toLowerCase();
          // ‚úÖ FIX: Use ONLY ONE event type (pointerup) to prevent double-firing
          if (ev === "click") {
            n.addEventListener("pointerup", (e) => { e.preventDefault(); v(e); });
          } else {
            n.addEventListener(ev, v);
          }
        } else n.setAttribute(k, v);
      }

      (Array.isArray(children) ? children : [children]).forEach(c => {
        if (c == null) return;
        n.appendChild(typeof c === "string" ? document.createTextNode(c) : c);
      });
      return n;
    }

    // ‚úÖ UI lock management
    let isNextRunning = false;

    function screen(node) {
      root.innerHTML = "";
      root.appendChild(node);
      state.blocking = false; // ‚úÖ FIX: Unlock input when screen updates
    }

    /** 10Á¥ö 80Â≠óÔºàÂõ∫ÂÆöÔºâ */
    const KANJI_10 = [
      "‰∏Ä", "Âè≥", "Èõ®", "ÂÜÜ", "Áéã", "Èü≥", "‰∏ã", "ÁÅ´", "Ëä±", "Ë≤ù",
      "Â≠¶", "Ê∞ó", "‰πù", "‰ºë", "Áéâ", "Èáë", "Á©∫", "Êúà", "Áä¨", "Ë¶ã",
      "‰∫î", "Âè£", "Ê†°", "Â∑¶", "‰∏â", "Â±±", "Â≠ê", "Âõõ", "Á≥∏", "Â≠ó",
      "ËÄ≥", "‰∏É", "Ëªä", "Êâã", "ÂçÅ", "Âá∫", "Â•≥", "Â∞è", "‰∏ä", "Ê£Æ",
      "‰∫∫", "Ê∞¥", "Ê≠£", "Áîü", "Èùí", "Â§ï", "Áü≥", "Ëµ§", "ÂçÉ", "Â∑ù",
      "ÂÖà", "Êó©", "Ëçâ", "Ë∂≥", "Êùë", "Â§ß", "Áî∑", "Á´π", "‰∏≠", "Ëô´",
      "Áî∫", "Â§©", "Áî∞", "Âúü", "‰∫å", "Êó•", "ÂÖ•", "Âπ¥", "ÁôΩ", "ÂÖ´",
      "Áôæ", "Êñá", "Êú®", "Êú¨", "Âêç", "ÁõÆ", "Á´ã", "Âäõ", "Êûó", "ÂÖ≠"
    ];

    /** Ë™≠„ÅøÔºà‰ª£Ë°®ÔºãË®±ÂÆπÔºâ */
    const READING = {
      "‰∏Ä": { main: "„ÅÑ„Å°", ok: ["„ÅÑ„Å°", "„Å≤„Å®"] },
      "Âè≥": { main: "„Åø„Åé", ok: ["„Åø„Åé"] },
      "Èõ®": { main: "„ÅÇ„ÇÅ", ok: ["„ÅÇ„ÇÅ"] },
      "ÂÜÜ": { main: "„Åà„Çì", ok: ["„Åà„Çì"] },
      "Áéã": { main: "„Åä„ÅÜ", ok: ["„Åä„ÅÜ"] },
      "Èü≥": { main: "„Åä„Å®", ok: ["„Åä„Å®"] },
      "‰∏ã": { main: "„Åó„Åü", ok: ["„Åó„Åü"] },
      "ÁÅ´": { main: "„Å≤", ok: ["„Å≤"] },
      "Ëä±": { main: "„ÅØ„Å™", ok: ["„ÅØ„Å™"] },
      "Ë≤ù": { main: "„Åã„ÅÑ", ok: ["„Åã„ÅÑ"] },

      "Â≠¶": { main: "„Åæ„Å™„Å∂", ok: ["„Åæ„Å™„Å∂", "„Åå„Åè"] },
      "Ê∞ó": { main: "„Åç", ok: ["„Åç"] },
      "‰πù": { main: "„Åç„ÇÖ„ÅÜ", ok: ["„Åç„ÇÖ„ÅÜ"] },
      "‰ºë": { main: "„ÇÑ„Åô„ÇÄ", ok: ["„ÇÑ„Åô„ÇÄ", "„ÇÑ„Åô"] },
      "Áéâ": { main: "„Åü„Åæ", ok: ["„Åü„Åæ"] },
      "Èáë": { main: "„Åç„Çì", ok: ["„Åç„Çì", "„Åã„Å≠"] },
      "Á©∫": { main: "„Åù„Çâ", ok: ["„Åù„Çâ"] },
      "Êúà": { main: "„Å§„Åç", ok: ["„Å§„Åç"] },
      "Áä¨": { main: "„ÅÑ„Å¨", ok: ["„ÅÑ„Å¨"] },
      "Ë¶ã": { main: "„Åø„Çã", ok: ["„Åø„Çã"] },

      "‰∫î": { main: "„Åî", ok: ["„Åî"] },
      "Âè£": { main: "„Åè„Å°", ok: ["„Åè„Å°"] },
      "Ê†°": { main: "„Åì„ÅÜ", ok: ["„Åì„ÅÜ"] },
      "Â∑¶": { main: "„Å≤„Å†„Çä", ok: ["„Å≤„Å†„Çä"] },
      "‰∏â": { main: "„Åï„Çì", ok: ["„Åï„Çì"] },
      "Â±±": { main: "„ÇÑ„Åæ", ok: ["„ÇÑ„Åæ"] },
      "Â≠ê": { main: "„Åì", ok: ["„Åì"] },
      "Âõõ": { main: "„Çà„Çì", ok: ["„Çà„Çì", "„Åó"] },
      "Á≥∏": { main: "„ÅÑ„Å®", ok: ["„ÅÑ„Å®"] },
      "Â≠ó": { main: "„Åò", ok: ["„Åò"] },

      "ËÄ≥": { main: "„Åø„Åø", ok: ["„Åø„Åø"] },
      "‰∏É": { main: "„Å™„Å™", ok: ["„Å™„Å™", "„Åó„Å°"] },
      "Ëªä": { main: "„Åè„Çã„Åæ", ok: ["„Åè„Çã„Åæ"] },
      "Êâã": { main: "„Å¶", ok: ["„Å¶"] },
      "ÂçÅ": { main: "„Åò„ÇÖ„ÅÜ", ok: ["„Åò„ÇÖ„ÅÜ", "„Å®„Åä"] },
      "Âá∫": { main: "„Åß„Çã", ok: ["„Åß„Çã", "„Å†„Åô"] },
      "Â•≥": { main: "„Åä„Çì„Å™", ok: ["„Åä„Çì„Å™"] },
      "Â∞è": { main: "„Å°„ÅÑ„Åï„ÅÑ", ok: ["„Å°„ÅÑ„Åï„ÅÑ", "„Å°„ÅÑ"] },
      "‰∏ä": { main: "„ÅÜ„Åà", ok: ["„ÅÜ„Åà"] },
      "Ê£Æ": { main: "„ÇÇ„Çä", ok: ["„ÇÇ„Çä"] },

      "‰∫∫": { main: "„Å≤„Å®", ok: ["„Å≤„Å®"] },
      "Ê∞¥": { main: "„Åø„Åö", ok: ["„Åø„Åö"] },
      "Ê≠£": { main: "„Åü„Å†„Åó„ÅÑ", ok: ["„Åü„Å†„Åó„ÅÑ"] },
      "Áîü": { main: "„ÅÑ„Åç„Çã", ok: ["„ÅÑ„Åç„Çã", "„Å™„Åæ"] },
      "Èùí": { main: "„ÅÇ„Åä", ok: ["„ÅÇ„Åä"] },
      "Â§ï": { main: "„ÇÜ„ÅÜ", ok: ["„ÇÜ„ÅÜ"] },
      "Áü≥": { main: "„ÅÑ„Åó", ok: ["„ÅÑ„Åó"] },
      "Ëµ§": { main: "„ÅÇ„Åã", ok: ["„ÅÇ„Åã"] },
      "ÂçÉ": { main: "„Åõ„Çì", ok: ["„Åõ„Çì"] },
      "Â∑ù": { main: "„Åã„Çè", ok: ["„Åã„Çè"] },

      "ÂÖà": { main: "„Åï„Åç", ok: ["„Åï„Åç"] },
      "Êó©": { main: "„ÅØ„ÇÑ„ÅÑ", ok: ["„ÅØ„ÇÑ„ÅÑ"] },
      "Ëçâ": { main: "„Åè„Åï", ok: ["„Åè„Åï"] },
      "Ë∂≥": { main: "„ÅÇ„Åó", ok: ["„ÅÇ„Åó"] },
      "Êùë": { main: "„ÇÄ„Çâ", ok: ["„ÇÄ„Çâ"] },
      "Â§ß": { main: "„Åä„Åä„Åç„ÅÑ", ok: ["„Åä„Åä„Åç„ÅÑ", "„Åä„Åä"] },
      "Áî∑": { main: "„Åä„Å®„Åì", ok: ["„Åä„Å®„Åì"] },
      "Á´π": { main: "„Åü„Åë", ok: ["„Åü„Åë"] },
      "‰∏≠": { main: "„Å™„Åã", ok: ["„Å™„Åã"] },
      "Ëô´": { main: "„ÇÄ„Åó", ok: ["„ÇÄ„Åó"] },

      "Áî∫": { main: "„Åæ„Å°", ok: ["„Åæ„Å°"] },
      "Â§©": { main: "„Å¶„Çì", ok: ["„Å¶„Çì"] },
      "Áî∞": { main: "„Åü", ok: ["„Åü"] },
      "Âúü": { main: "„Å§„Å°", ok: ["„Å§„Å°"] },
      "‰∫å": { main: "„Å´", ok: ["„Å´"] },
      "Êó•": { main: "„Å≤", ok: ["„Å≤"] },
      "ÂÖ•": { main: "„ÅØ„ÅÑ„Çã", ok: ["„ÅØ„ÅÑ„Çã", "„ÅÑ„Çã"] },
      "Âπ¥": { main: "„Å®„Åó", ok: ["„Å®„Åó", "„Å≠„Çì"] },
      "ÁôΩ": { main: "„Åó„Çç", ok: ["„Åó„Çç"] },
      "ÂÖ´": { main: "„ÅØ„Å°", ok: ["„ÅØ„Å°"] },

      "Áôæ": { main: "„Å≤„ÇÉ„Åè", ok: ["„Å≤„ÇÉ„Åè"] },
      "Êñá": { main: "„Å∂„Çì", ok: ["„Å∂„Çì"] },
      "Êú®": { main: "„Åç", ok: ["„Åç"] },
      "Êú¨": { main: "„Åª„Çì", ok: ["„Åª„Çì"] },
      "Âêç": { main: "„Å™„Åæ„Åà", ok: ["„Å™„Åæ„Åà"] },
      "ÁõÆ": { main: "„ÇÅ", ok: ["„ÇÅ"] },
      "Á´ã": { main: "„Åü„Å§", ok: ["„Åü„Å§"] },
      "Âäõ": { main: "„Å°„Åã„Çâ", ok: ["„Å°„Åã„Çâ"] },
      "Êûó": { main: "„ÅØ„ÇÑ„Åó", ok: ["„ÅØ„ÇÑ„Åó"] },
      "ÂÖ≠": { main: "„Çç„Åè", ok: ["„Çç„Åè"] }
    };

    /* ---------- Save / State ---------- */
    const STORAGE_KEY = "kanken10_master_v2";
    const STROKE_CACHE_KEY = "kvgStrokeCache_10kyu_v2";

    const state = {
      mode: "home",
      blocking: false, // ‚úÖ FIX: Execution guard
      progress: {},
      mistakes: {},
      session: {
        limit: 20,
        done: 0,
        correct: 0,
        total: 0,
        rankUps: {},
        newlyMastered: new Set()
      }
    };

    function initProgress() {
      for (const k of KANJI_10) {
        if (typeof state.progress[k] !== "number") state.progress[k] = 0;
      }
    }

    function load() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (raw) {
          const s = JSON.parse(raw);
          state.progress = s.progress || {};
          state.mistakes = s.mistakes || {};
        }
      } catch (e) { }
      initProgress();
    }
    function save() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        progress: state.progress,
        mistakes: state.mistakes
      }));
    }

    function masteredCount() {
      return Object.values(state.progress).filter(v => v === 3).length;
    }
    function calcLevel() {
      const m = masteredCount();
      return Math.floor(m / 10) + 1;
    }
    function renderHud() {
      const m = masteredCount();
      levelEl.textContent = String(calcLevel());
      masteredEl.textContent = String(m);
      todayDoneEl.textContent = String(state.session.done || 0);
      limitEl.textContent = String(state.session.limit || 20);
      const pct = (m / 80) * 100;
      gaugeEl.style.width = clamp(pct, 0, 100) + "%";
    }

    /* ---------- Âá∫È°å„ÅÆÈáç„ÅøÔºà‰Ωé„É©„É≥„ÇØÔºÜ„Éü„ÇπÂ§ö„ÇÅ„ÇíÂÑ™ÂÖàÔºâ ---------- */
    function weightedPickKanji() {
      const weights = KANJI_10.map(k => {
        const rank = state.progress[k] || 0;
        const base = (3 - rank) + 1;
        const miss = (state.mistakes[k] || 0) * 2;
        const damp = (rank === 3) ? 0.4 : 1;
        return (base + miss) * damp;
      });
      const sum = weights.reduce((a, b) => a + b, 0);
      let r = Math.random() * sum;
      for (let i = 0; i < KANJI_10.length; i++) {
        r -= weights[i];
        if (r <= 0) return KANJI_10[i];
      }
      return KANJI_10[KANJI_10.length - 1];
    }

    function makeReadingChoices(correct, count = 3) {
      const pool = new Set([correct]);
      while (pool.size < count) {
        const k = KANJI_10[Math.floor(Math.random() * KANJI_10.length)];
        const cand = READING[k]?.main;
        if (cand && cand !== correct) pool.add(cand);
      }
      return shuffle([...pool]);
    }
    function makeKanjiChoices(correctKanji, count = 3) {
      const pool = new Set([correctKanji]);
      while (pool.size < count) {
        const k = weightedPickKanji();
        if (k !== correctKanji) pool.add(k);
      }
      return shuffle([...pool]);
    }

    /* ---------- Êõ∏„ÅçÈ†ÜÔºöKanjiVG ---------- */
    let strokeCache = {};
    try { strokeCache = JSON.parse(localStorage.getItem(STROKE_CACHE_KEY) || "{}"); } catch (e) { strokeCache = {}; }

    function codepointHex(ch) { return ch.codePointAt(0).toString(16).padStart(5, "0"); }

    function kvgUrlFor(ch) {
      const hex = codepointHex(ch);
      return `./kanji-svg/${hex}.svg`; // ‚úÖ FIX: Local path
    }

    function parseKanjiVG(svgText) {
      const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
      const paths = Array.from(doc.querySelectorAll("path"))
        .map(p => ({ id: p.getAttribute("id") || "", d: p.getAttribute("d") || "" }))
        .filter(x => x.d && /-s\d+/.test(x.id));

      paths.sort((a, b) => {
        const na = parseInt((a.id.match(/-s(\d+)/) || [])[1] || "9999", 10);
        const nb = parseInt((b.id.match(/-s(\d+)/) || [])[1] || "9999", 10);
        return na - nb;
      });

      const ds = paths.map(x => x.d);
      return ds.length ? ds : null;
    }

    // ‚úÖ FIX: Strict fetch with timeout helper
    async function fetchStrokeData(url, timeoutMs = 5000) {
      return Promise.race([
        (async () => {
          const res = await fetch(url, { cache: "no-store" });
          if (!res.ok) throw new Error("Status " + res.status);
          const txt = await res.text();
          const ds = parseKanjiVG(txt);
          if (!ds) throw new Error("No paths parsed");
          return ds;
        })(),
        new Promise((_, r) => setTimeout(() => r(new Error("Timeout " + timeoutMs + "ms")), timeoutMs))
      ]);
    }

    async function getStrokes(ch) {
      if (strokeCache[ch]?.ds) return strokeCache[ch].ds;

      let url = kvgUrlFor(ch);
      try {
        // Attempt 1
        const ds = await fetchStrokeData(url, 5000);
        strokeCache[ch] = { ds, t: Date.now() };
        localStorage.setItem(STROKE_CACHE_KEY, JSON.stringify(strokeCache));
        return ds;
      } catch (e1) {
        // Retry with cache buster
        try {
          const retryUrl = url + "?t=" + Date.now();
          const ds = await fetchStrokeData(retryUrl, 5000);
          strokeCache[ch] = { ds, t: Date.now() };
          localStorage.setItem(STROKE_CACHE_KEY, JSON.stringify(strokeCache));
          return ds;
        } catch (e2) {
          throw new Error(`Failed loading ${ch} (${url}): ${e2.message}`);
        }
      }
    }

    function makeStrokeSvg(ds, redIndex) {
      const svgNS = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("viewBox", "0 0 109 109");

      ds.forEach(d => {
        const p = document.createElementNS(svgNS, "path");
        p.setAttribute("d", d);
        p.setAttribute("class", "strokeBase");
        svg.appendChild(p);
      });

      const r = ds[redIndex - 1];
      if (r) {
        const p = document.createElementNS(svgNS, "path");
        p.setAttribute("d", r);
        p.setAttribute("class", "strokeRed");
        svg.appendChild(p);
      }
      return svg;
    }

    /* ---------- ÂêàÊ†ºÂäõÔºà„É©„É≥„ÇØÔºâÊõ¥Êñ∞ ---------- */
    function tryRankUp(kanji, targetRank) {
      if (state.mode === "mock") return;
      const prev = state.progress[kanji] || 0;
      const next = Math.max(prev, targetRank);
      if (next > prev) {
        state.progress[kanji] = next;
        state.session.rankUps[kanji] = state.session.rankUps[kanji] || { from: prev, to: next };
        state.session.rankUps[kanji].to = next;
        if (next === 3 && prev < 3) state.session.newlyMastered.add(kanji);
        save();
        renderHud();
      }
    }

    /* ---------- „Éü„ÇπÁÆ°ÁêÜ ---------- */
    function addMistake(kanji) {
      state.mistakes[kanji] = (state.mistakes[kanji] || 0) + 1;
      save();
    }
    function reduceMistake(kanji) {
      if (!state.mistakes[kanji]) return;
      state.mistakes[kanji] = Math.max(0, state.mistakes[kanji] - 1);
      if (state.mistakes[kanji] === 0) delete state.mistakes[kanji];
      save();
    }

    /* ---------- ÁîªÈù¢ ---------- */
    function viewHome() {
      state.mode = "home";
      state.session = { limit: 20, done: 0, correct: 0, total: 0, rankUps: {}, newlyMastered: new Set() };
      renderHud();

      const card = el("div", { class: "screen" }, [
        el("div", { class: "tag" }, "„É°„Éã„É•„Éº"),
        el("div", { class: "title" }, "„Åã„Çì„Åë„Çì10„Åç„ÇÖ„ÅÜ"),
        el("div", { class: "subtitle" }, "ÂêàÊ†ºÂäõÔºà„É©„É≥„ÇØÔºâ„Åß‰ªï‰∏ä„Åí„ÇãÔºÅ"),
        el("div", { class: "grid" }, [
          el("button", { class: "btn", type: "button", onClick: () => startMode("yomi") }, "üìñ „Çà„Åø„Åã„ÅüÔºà0‚Üí1Ôºâ"),
          el("button", { class: "btn", type: "button", onClick: () => startMode("kakuSelect") }, "‚úèÔ∏è „Åà„Çâ„Çì„Åß „Åã„ÅèÔºà1‚Üí2Ôºâ"),
          el("button", { class: "btn", type: "button", onClick: () => startMode("kakijun") }, "1Ô∏è‚É£ „Åã„Åç„Åò„ÇÖ„ÇìÔºà2‚Üí3Ôºâ"),
          el("button", { class: "btn btnAccent", type: "button", onClick: () => startMode("mock") }, "‚è±Ô∏è 10„Åç„ÇÖ„ÅÜ„ÉÅ„É£„É¨„É≥„Ç∏ÔºàÁ¢∫Ë™çÔºâ"),
        ]),
        el("div", { class: "footerNote" },
          "ÂêÑ„É¢„Éº„Éâ„ÅØ 20Âïè„Åß „Åä„Çè„Çã„ÇàÔºàÊ®°Ë©¶„ÅØ10ÂïèÔºâ„ÄÇ\n" +
          "Êõ∏„ÅçÈ†Ü„ÅØ KanjiVG „ÅÆ„Çπ„Éà„É≠„Éº„ÇØÈ†ÜSVG„ÇíÂà©Áî®ÔºàÂàùÂõû„Éç„ÉÉ„ÉàÂøÖË¶ÅÔºâ„ÄÇ\n" +
          "¬© KanjiVG: CC BY-SA 3.0"
        )
      ]);
      screen(card);
    }

    // ‚úÖ FIX: Enhanced loading screen
    function viewLoading(kanji, url, onRetry, onSkip) {
      const card = el("div", { class: "screen" }, [
        el("div", { class: "tag" }, "„Åã„Åç„Åò„ÇÖ„Çì"),
        el("div", { class: "loading" }, [
          el("div", { class: "spinner" }),
          el("div", {}, `„Äå${kanji}„Äç„Çí „Çà„Åø„Åì„Åø„Å°„ÇÖ„ÅÜ‚Ä¶`),
          el("div", { style: "font-size:10px;color:#94a3b8;margin-top:8px;" }, url)
        ]),
        el("div", { style: "display:flex;gap:10px;margin-top:10px;" }, [
          onRetry ? el("button", { class: "btn btnWide", type: "button", onClick: onRetry }, "„ÇÇ„ÅÜ„ÅÑ„Å°„Å©") : null,
          onSkip ? el("button", { class: "btn btnWide", type: "button", onClick: onSkip }, "„Çπ„Ç≠„ÉÉ„Éó„Åô„Çã") : null
        ]),
        el("button", { class: "btn btnWide btnAccent", style: "margin-top:10px;", type: "button", onClick: viewHome }, "„É°„Éã„É•„Éº„Å´„ÇÇ„Å©„Çã")
      ]);
      screen(card);
    }

    function viewErrorLoad(kanji, err, onRetry, onSkip) {
      const card = el("div", { class: "screen" }, [
        el("div", { class: "tag" }, "„Ç®„É©„Éº"),
        el("div", { class: "title", style: "margin-top:18px;font-size:30px;color:#ef4444;" }, "„Çà„Åø„Åì„ÇÅ„Å™„ÅÑ‚Ä¶"),
        el("div", { class: "warn" }, `„Äå${kanji}„Äç„ÅÆ„Éá„Éº„Çø„ÅÇ„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ\n${err.message}`),
        el("div", { style: "display:flex;gap:10px;margin-top:10px;" }, [
          el("button", { class: "btn btnWide", type: "button", onClick: onRetry }, "„ÇÇ„ÅÜ„ÅÑ„Å°„Å©"),
          el("button", { class: "btn btnWide", type: "button", onClick: onSkip }, "„Çπ„Ç≠„ÉÉ„Éó")
        ]),
        el("button", { class: "btn btnWide btnAccent", style: "margin-top:10px;", type: "button", onClick: viewHome }, "„É°„Éã„É•„Éº„Å´„ÇÇ„Å©„Çã")
      ]);
      screen(card);
    }

    function viewQuestion(q) {
      const explain = el("div", { class: "explain", id: "explain" }, q.explain || "");
      const choicesWrap = el("div", { class: "choices" },
        q.choices.map(c =>
          el("button", { class: "choice", type: "button", onClick: () => judge(q, c) }, c)
        )
      );

      const parts = [];
      parts.push(el("div", { class: "tag" }, q.tag));
      if (q.type === "yomi") {
        parts.push(el("div", { class: "qBigKanji" }, q.kanji));
        parts.push(el("div", { class: "prompt" }, "„Å™„Çì„Å¶ „Çà„ÇÄ„Åã„Å™Ôºü"));
      }
      if (q.type === "kakuSelect") {
        parts.push(el("div", { class: "qBigKana" }, q.reading));
        parts.push(el("div", { class: "prompt" }, `„Äå${q.reading}„Äç„ÅÆ „Åã„Çì„Åò„ÅØÔºü`));
      }
      if (q.type === "kakijun") {
        parts.push(el("div", { class: "svgBox" }, q.svgNode));
        parts.push(el("div", { class: "prompt" }, "„ÅÇ„Åã„ÅÑ„Å®„Åì„Çç„ÅØ „Å™„Çì„Å∞„Çì„ÇÅÔºü"));
      }
      if (q.type === "mock") {
        parts.push(el("div", { class: "prompt" }, "10„Åç„ÇÖ„ÅÜ„ÉÅ„É£„É¨„É≥„Ç∏Ôºà„É©„É≥„ÇØ„ÅØ‰∏ä„Åå„Çâ„Å™„ÅÑÔºâ"));
        if (q.innerType === "yomi") parts.push(el("div", { class: "qBigKanji" }, q.kanji));
        if (q.innerType === "kakuSelect") parts.push(el("div", { class: "qBigKana" }, q.reading));
        parts.push(el("div", { class: "prompt" }, q.innerType === "yomi" ? "„Å™„Çì„Å¶ „Çà„ÇÄ„Åã„Å™Ôºü" : `„Äå${q.reading}„Äç„ÅÆ „Åã„Çì„Åò„ÅØÔºü`));
      }

      parts.push(el("div", { class: "counter" }, q.counterText));
      parts.push(choicesWrap);
      parts.push(explain);

      screen(el("div", { class: "screen" }, parts));
    }

    function showExplain() {
      const e = document.getElementById("explain");
      if (e) e.style.display = "block";
    }

    function viewResult() {
      const modeName = ({
        yomi: "„Çà„Åø„Åã„Åü",
        kakuSelect: "„Åà„Çâ„Çì„Åß „Åã„Åè",
        kakijun: "„Åã„Åç„Åò„ÇÖ„Çì",
        mock: "10„Åç„ÇÖ„ÅÜ„ÉÅ„É£„É¨„É≥„Ç∏"
      })[state.mode] || "„Åë„Å£„Åã";

      const rankUpList = Object.entries(state.session.rankUps)
        .map(([k, v]) => ({ k, from: v.from, to: v.to }))
        .sort((a, b) => (b.to - b.from) - (a.to - a.from));

      const newly = Array.from(state.session.newlyMastered);

      const tomorrow = KANJI_10
        .map(k => ({ k, rank: state.progress[k] || 0, miss: state.mistakes[k] || 0 }))
        .sort((a, b) => {
          if (a.rank !== b.rank) return a.rank - b.rank;
          return b.miss - a.miss;
        })
        .slice(0, 10)
        .map(x => x.k);

      const card = el("div", { class: "screen" }, [
        el("div", { class: "tag" }, "„Åë„Å£„Åã"),
        el("div", { class: "title", style: "margin-top:18px;font-size:34px;" }, "„Åç„Çá„ÅÜ„ÅÆ „Åó„ÇÅÔºÅ"),
        el("div", { class: "subtitle" }, `${modeName}Ôºö${state.session.done}„ÇÇ„Çì „Åä„Çè„Çä`),
        el("div", { style: "text-align:center;font-weight:1100;font-size:18px;margin-top:8px;" },
          `„Åõ„ÅÑ„Åã„ÅÑÔºö${state.session.correct} / ${state.session.total}`
        ),

        el("div", { class: "footerNote" }, "„É©„É≥„ÇØUP„Åó„Åü „Åã„Çì„Åò"),
        el("div", { class: "chips" },
          rankUpList.length
            ? rankUpList.slice(0, 18).map(x => {
              const cls = (x.to === 3) ? "chip chipGood" : "chip";
              return el("div", { class: cls }, `${x.k}  ${x.from}‚Üí${x.to}`);
            })
            : [el("div", { class: "chip" }, "„Å™„ÅóÔºàÊ¨°„ÅØ‰∏ä„Åå„Çã„ÇàÔºÅÔºâ")]
        ),

        el("div", { class: "footerNote" }, "„Åç„Çá„ÅÜ ÂÆåÊàêÔºà„É©„É≥„ÇØ3Ôºâ„Å´„Å™„Å£„Åü „Åã„Çì„Åò"),
        el("div", { class: "chips" },
          newly.length
            ? newly.map(k => el("div", { class: "chip chipGood" }, k))
            : [el("div", { class: "chip" }, "„Å™„ÅóÔºà„ÅÇ„Å®Â∞ë„ÅóÔºÅÔºâ")]
        ),

        el("div", { class: "footerNote" }, "„ÅÇ„Åó„Åü„ÅÆ „Åä„Åô„Åô„ÇÅ10Â≠óÔºàÂº±„ÅÑÈ†ÜÔºâ"),
        el("div", { class: "chips" }, tomorrow.map(k => el("div", { class: "chip chipNew" }, k))),

        el("div", { style: "display:flex;gap:10px;margin-top:14px;" }, [
          el("button", { class: "btn btnWide", type: "button", onClick: () => startMode(state.mode) }, "„ÇÇ„ÅÜ1„Çª„ÉÉ„Éà"),
          el("button", { class: "btn btnWide btnAccent", type: "button", onClick: viewHome }, "„É°„Éã„É•„Éº")
        ])
      ]);
      screen(card);
    }

    /* ---------- „É¢„Éº„ÉâÈÄ≤Ë°å ---------- */
    function startMode(mode) {
      state.mode = mode;
      state.session = {
        limit: (mode === "mock") ? 10 : 20,
        done: 0, correct: 0, total: 0,
        rankUps: {}, newlyMastered: new Set()
      };
      renderHud();
      next();
    }

    async function next() {
      // ‚úÖ FIX: Concurrent execution guard
      if (isNextRunning) return;
      isNextRunning = true;

      try {
        if (state.session.done >= state.session.limit) {
          viewResult();
          return;
        }

        if (state.mode === "yomi") {
          const kanji = weightedPickKanji();
          const rd = READING[kanji];
          const q = {
            type: "yomi",
            tag: "„Çà„Åø„Åã„ÅüÔºà0‚Üí1Ôºâ",
            kanji,
            choices: makeReadingChoices(rd.main, 3),
            answer: rd.main,
            okReadings: rd.ok,
            explain: rd.ok,
            explain: rd.ok.length > 1 ? `„Åª„Åã„ÅÆ „Çà„ÅøÔºö${rd.ok.join(" / ")}` : "",
            counterText: `„ÇÇ„Çì„Å†„ÅÑ ${state.session.done + 1}/${state.session.limit}Ôºà„Åì„ÅÆÂ≠ó„É©„É≥„ÇØÔºö${state.progress[kanji] || 0}Ôºâ`
          };
          viewQuestion(q);
          return;
        }

        if (state.mode === "kakuSelect") {
          const kanji = weightedPickKanji();
          const rd = READING[kanji];
          const q = {
            type: "kakuSelect",
            tag: "„Åà„Çâ„Çì„Åß „Åã„ÅèÔºà1‚Üí2Ôºâ",
            kanji,
            reading: rd.main,
            choices: makeKanjiChoices(kanji, 3),
            answer: kanji,
            explain: "",
            counterText: `„ÇÇ„Çì„Å†„ÅÑ ${state.session.done + 1}/${state.session.limit}Ôºà„Åì„ÅÆÂ≠ó„É©„É≥„ÇØÔºö${state.progress[kanji] || 0}Ôºâ`
          };
          viewQuestion(q);
          return;
        }

        if (state.mode === "kakijun") {
          const kanji = weightedPickKanji();

          /* ‚úÖ FIX: Retry / Skip Logic */
          const doLoad = async () => {
            // Show loading with retry/skip attached
            viewLoading(kanji, kvgUrlFor(kanji),
              () => doLoad(), // Retry
              () => {         // Skip
                state.session.total += 1;
                state.session.done += 1;
                renderHud();
                isNextRunning = false;
                next();
              }
            );

            try {
              const ds = await getStrokes(kanji);
              const total = ds.length;
              const redIndex = 1 + Math.floor(Math.random() * total);
              const choiceNums = new Set([redIndex]);
              while (choiceNums.size < 3) {
                const delta = [-2, -1, 1, 2][Math.floor(Math.random() * 4)];
                choiceNums.add(clamp(redIndex + delta, 1, total));
              }
              const choices = shuffle([...choiceNums].map(n => `${n}„Åã„Åè„ÇÅ`));

              const q = {
                type: "kakijun",
                tag: "„Åã„Åç„Åò„ÇÖ„ÇìÔºà2‚Üí3Ôºâ",
                kanji,
                svgNode: makeStrokeSvg(ds, redIndex),
                choices,
                answer: `${redIndex}„Åã„Åè„ÇÅ`,
                explain: `„Äå${kanji}„Äç„ÅØ „Åú„Çì„Å∂„Åß ${total}„Åã„Åè„ÄÇ`,
                counterText: `„ÇÇ„Çì„Å†„ÅÑ ${state.session.done + 1}/${state.session.limit}Ôºà„Åì„ÅÆÂ≠ó„É©„É≥„ÇØÔºö${state.progress[kanji] || 0}Ôºâ`
              };
              viewQuestion(q);

            } catch (err) {
              console.error(err);
              viewErrorLoad(kanji, err,
                () => doLoad(), // Retry
                () => {         // Skip
                  state.session.total += 1;
                  state.session.done += 1;
                  renderHud();
                  isNextRunning = false;
                  next();
                }
              );
            }
          };

          await doLoad();
          return;
        }

        if (state.mode === "mock") {
          const kanji = weightedPickKanji();
          const inner = (Math.random() < 0.7) ? "yomi" : "kakuSelect";

          if (inner === "yomi") {
            const rd = READING[kanji];
            const q = {
              type: "mock",
              innerType: "yomi",
              kanji,
              choices: makeReadingChoices(rd.main, 3),
              answer: rd.main,
              okReadings: rd.ok,
              explain: rd.ok.length > 1 ? `„Åª„Åã„ÅÆ „Çà„ÅøÔºö${rd.ok.join(" / ")}` : "",
              counterText: `„ÇÇ„Çì„Å†„ÅÑ ${state.session.done + 1}/${state.session.limit}`
            };
            viewQuestion(q);
            return;
          } else {
            const rd = READING[kanji];
            const q = {
              type: "mock",
              innerType: "kakuSelect",
              kanji,
              reading: rd.main,
              choices: makeKanjiChoices(kanji, 3),
              answer: kanji,
              explain: "",
              counterText: `„ÇÇ„Çì„Å†„ÅÑ ${state.session.done + 1}/${state.session.limit}`
            };
            viewQuestion(q);
            return;
          }
        }
      } catch (err) {
        // Fallback for other errors
        console.error(err);
        toast("„Ç∑„Çπ„ÉÜ„É†„Ç®„É©„Éº");
      } finally {
        if (state.mode !== "kakijun") isNextRunning = false;
        // Note: kakijun handles isNextRunning=false internally when it finishes or skips
      }
    }

    /* ---------- Âà§ÂÆö ---------- */
    function judge(q, picked) {
      if (state.blocking) return; // ‚úÖ FIX: Prevent re-entry
      state.blocking = true;

      showExplain();

      state.session.total += 1;
      state.session.done += 1;
      renderHud();

      let ok = false;

      if (q.type === "yomi" || (q.type === "mock" && q.innerType === "yomi")) {
        ok = (q.okReadings || []).includes(picked);
      } else {
        ok = (picked === q.answer);
      }

      if (ok) {
        state.session.correct += 1;
        reduceMistake(q.kanji);

        if (state.mode === "yomi") tryRankUp(q.kanji, 1);
        if (state.mode === "kakuSelect") tryRankUp(q.kanji, 2);
        if (state.mode === "kakijun") tryRankUp(q.kanji, 3);

        showFeedback(true, "„Åõ„ÅÑ„Åã„ÅÑÔºÅ");
        setTimeout(() => {
          state.blocking = false; // unlock handled by screen() clearing, but explicit here too
          isNextRunning = false;  // Ensure next can run
          next();
        }, 700);
      } else {
        addMistake(q.kanji);
        showFeedback(false, "„Åñ„Çì„Å≠„Çì‚Ä¶");
        toast(`„Åì„Åü„ÅàÔºö${q.answer}`); // Toast specifically for the answer
        setTimeout(() => {
          state.blocking = false;
          isNextRunning = false;
          next();
        }, 1200);
      }
    }

    /* ---------- „Éú„Çø„É≥ ---------- */
    document.getElementById("homeBtn").addEventListener("click", viewHome);
    document.getElementById("resetBtn").addEventListener("click", () => {
      if (confirm("Â≠¶Áøí„Éá„Éº„Çø„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åô„ÅãÔºüÔºà„É©„É≥„ÇØ„ÉªËã¶ÊâãË®òÈå≤„ÅåÊ∂à„Åà„Åæ„ÅôÔºâ")) {
        localStorage.removeItem(STORAGE_KEY);
        localStorage.removeItem(STROKE_CACHE_KEY);
        strokeCache = {};
        state.progress = {};
        state.mistakes = {};
        initProgress();
        save();
        toast("„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü");
        viewHome();
      }
    });

    /* ‚úÖ „ÄåÁÑ°ÂèçÂøú„Äç„ÇíÊ†πÁµ∂Ôºö„Ç®„É©„Éº„ÇíÂøÖ„ÅöÁîªÈù¢„Å´Âá∫„Åô */
    window.addEventListener("error", (e) => {
      const msg = (e && e.message) ? e.message : "Unknown error";
      showFatal("window.error:\n" + msg + "\n\n" + (e?.filename ? (e.filename + ":" + e.lineno + ":" + e.colno) : ""));
    });
    window.addEventListener("unhandledrejection", (e) => {
      showFatal("unhandledrejection:\n" + (e?.reason?.message || String(e?.reason || e)));
    });

    /* ---------- Ëµ∑Âãï ---------- */
    load();
    renderHud();
    viewHome();
  </script>
</body>

</html>